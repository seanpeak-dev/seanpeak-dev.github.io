---
date: '2021-10-25'
title: '이벤트'
categories: ['자바스크립트']
summary: '자바스크립트 이벤트'
---

## 이벤트 드리븐 프로그래밍
이벤트가 발생했을 때 호출될 함수를 **이벤트 핸들러**라 하고,  
이벤트가 발생했을 때 브라우저에게 이벤트 핸들러의 호출을 위임하는 것을 **이벤트 핸들러 등록**이라 한다.

### 이벤트 타입
이벤트의 종류를 나타내는 문자열이다. [참조문서](https://developer.mozilla.org/ko/docs/Web/Events)  
- mouseenter/mouseleave와 mouseover/mouseout의 차이는 전자는 버블링이 되지 않고, 후자는 버블링된다.  
- keypress는 문자 키를 눌렀을 때 연속적으로 발생하고, keydown은 문자 키의 경우는 keypress와 동일하지만 그 외의 키는 한 번만 발생한다.
- 포커스 이벤트인 focus와 blur는 버블링되지 않는다.
- 값 변경 이벤트 중 input과 change의 차이는 change의 이벤트의 경우 포커스를 잃었을 때 사용자 입력이 종료되었다고 인식하여 발생한다. 즉, 사용자가 입력을 하고 있을 때는 input 이벤트가 발생하고 사용자 입력이 종료되어 값이 변경되면 change 이벤트가 발생한다.
- HTML 문서의 로드와 파싱이 완료되어 DOM 생성이 완료되면 DOMContentLoaded 이벤트가 발생한다.
- HTML 문서의 로드와 파싱 상태를 나타내는 readyState의 프로퍼티 값('loading', 'interactive', 'complete')이 변경되면 readystatechange 이벤트가 발생한다.
- DOMContentLoaded 이벤트가 발생한 이후 모든 리소스의 로딩이 완료되면 load 이벤트가 발생한다.
- 리소스가 언로드 될 때, 주로 새로운 웹페이지를 요청한 경우 unload 이벤트가 발생한다.

## 이벤트 핸들러를 등록하는 방법
### 1. 이벤트 핸들러 어트리뷰트 방식
이벤트 핸들러 어트리뷰트 이름은 onclick과 같이 on 접두사와 이벤트의 종류를 나타내는 이벤트 타입으로 이루어져 있다.
```html
<button onclick="sayHi('Sean')">Click me!</button>
```
```javascript
function onclick(event) {
	sayHi('Sean');
}
```
이벤트 핸들러의 어트리뷰트 값은 사실 암묵적으로 생성될 이벤트 핸들러의 함수 몸체를 의미한다.
따라서 이벤트 핸들러 어트리뷰트 값으로 여러 개의 문을 할당할 수 있다.  
주의할 점은 이벤트 핸들러. 어트리뷰트 값으로 함수 참조가 아닌 문을 할당한다는 것이다.  
CBD 방식의 프레임워크나 라이브러리에서는 이벤트 핸들러 어트리뷰트 방식으로 이벤트를 처리한다. HTML, CSS, 자바스크립트를 관심사가 다른 개별적인 요소가 아닌 뷰를 구성하기 위한 구성 요소로 보기 때문에 관심사가 다르다고 생각하지 않는다.

### 2. 이벤트 핸들러 프로퍼티 방식
DOM 노드 객체는 이벤트에 대응하는 이벤트 핸들러 프로퍼티를 가지고 있다. 이벤트 핸들러 프로퍼티에 함수를 바인딩하면 이벤트 핸들러가 등록된다.
```javascript
const $button = document.querySelector('button');

$button.onclick = function() {
	console.log('button click');
}
```
이벤트 핸들러 어트리뷰트 방식도 결국 DOM 노드 객체의 이벤트 핸들러 프로퍼티로 변환되므로 결과적으로 이벤트 핸들러 프로퍼티 방식과 동일하다고 할 수 있다.
하지만 이벤트 핸들러 프로퍼티에 하나의 이벤트 핸들러만 바인딩할 수 있다.  
이벤트 핸들러를 제거하려면 이벤트 핸들러 프로퍼티에 null을 할당한다.

### 3. addEventListener 메서드 방식
`EventTarget.prototype.addEventListener`은 DOM Level 2에서 도입되었다. 앞서 살펴본 방식들은 DOM Level 0부터 제공되던 방식이다.
```javascript
const $button = document.querySelector('button');

$button.addEventListener('click', function(){
	console.log('button click');
});
```
addEventListener 메서드는 하나 이상의 이벤트 핸들러를 등록할 수 있다.  
세 번째 매개변수로 이벤트를 캐치할 이벤트 전파 단계를 지정할 수 있다. 기본값은 false로 버블링 단계에서 이벤트를 캐치하고, true를 지정하면 캡처링 단계에서 이벤트를 캐치한다.
`EventTarget.prototype.removeEventListener` : addEventListener 메서드에 전달한 인수와 removeEventListener 메서드에 전달한 인수가 일치하지 않으면 이벤트 핸들러가 제거되지 않는다.
따라서 무명 함수를 이벤트 핸들러로 등록한 경우 제거할 수 없다. 이벤트 핸들러의 참조를 변수나 자료구조에 저장하고 있어야 한다.

## 이벤트 객체
이벤트가 발생하면 이벤트 객체가 동적으로 생성되고, 생성된 이벤트 객체는 이벤트 핸들러의 첫 번째 인수로 전달된다.  

이벤트 핸들러 어트리뷰트 방식의 경우 이벤트 객체를 전달받으려면 이벤트 핸들러의 첫 번째 매개변수 이름이 반드시 event이어야 한다.  

이벤트가 발생하면 이벤트 타입에 따라 다양한 타입의 이벤트 객체가 생성된다. 예로 [MouseEvent](https://developer.mozilla.org/ko/docs/Web/API/MouseEvent) 는 해당 이름으로 된 생성자 함수를 호출하여 이벤트 객체를 생성할 수 있고,
click 이벤트가 발생하면 암묵적으로 생성되는 MouseEvent 타입의 이벤트 객체는 `Event <- UIEvent <- MouseEvent` 프로토타입 체인의 일원이 된다.  

[Event](https://developer.mozilla.org/ko/docs/Web/API/Event) 인터페이스의 이벤트 관련 프로퍼티는 모든 이벤트 객체가 상속받는 공통 프로퍼티다. 이 중 target 프로퍼티는 이벤트를 발생시킨 DOM 요소를 나타내고, currentTarget 프로퍼티는 이벤트 핸들러가 바인딩된 DOM 요소를 가리킨다.  

그 외에도 type, eventPhase(이벤트 전파 단계를 숫자로 구분), bubbles(이벤트를 버블링으로 전파하는지 여부, 특정 이벤트들은 버블링하지 않음), cancelable(preventDefault 메서드를 호출하여 이벤트의 기본 동작을 취소할 수 있는지 여부), defaultPrevented, isTrusted(사용자의 행위에 의해 발생한 이벤트인지 여부, click 메서드 또는 dispatchEvent 메서드를 통해 인위적으로 발생시킨 이벤트인 경우 false), timeStamp가 있다.  

MouseEvent 타입의 이벤트 객체는 마우스 포인터의 좌표 정보를 나타내는 프로퍼티를 고유의 프로퍼티로 갖는다. 예로 드래그는 mousedown 이벤트가 발생한 상태에서 mousemove 이벤트가 발생한 시점에 시작하고 mouseup 이벤트가 발생한 시점에 종료한다. 이를 이용하여 마우스 포인터의 좌표 정보를 나타내는 screenX/screenY, clientX/clientY, pageX/pageY, offsetX/offsetY 프로퍼티를 제공한다.

screen은 자신의 모니터 기준으로 마우스 포인터 좌표를 나타낸다. client는 뷰포트, 즉 웹페이지의 가시 영역을 기준으로 마우스 포인터 좌표를 나타낸다. page는 client와 비슷하지만 문서 전체가 기준이라 스크롤 영역을 포함하여 측정한다. offset은 이벤트가 걸려 있는 DOM 객체를 기준으로 마우스 포인터 좌표를 나타낸다.

KeyboardEvent 타입의 이벤트 객체는 버튼 정보를 나타내는 프로퍼티를 고유의 프로퍼티로 갖는다. 대표적으로 입력한 키 값을 문자열로 반환하는 key 프로퍼티를 제공한다. 입력한 키와 key 프로퍼티 값의 대응 관계는 [https://keycode.info/](https://keycode.info/) 를 참고한다. 참고로 input 요소의 입력 필드에 한글을 입력하고 엔터 키를 누르면 keyup 이벤트 핸들러가 두 번 호출되는 현상이 발생하기 때문에 keyup 이벤트 대신 keydown 이벤트를 캐치한다.

## 이벤트 전파(propagation)
KeyboardEvent 타입의 이벤트 객체는 버튼 정보를 나타내는 프로퍼티를 고유의 프로퍼티로 갖는다. 대표적으로 입력한 키 값을 문자열로 반환하는 key 프로퍼티를 제공한다. 입력한 키와 key 프로퍼티 값의 대응 관계는 [https://keycode.info/](https://keycode.info/) 를 참고한다. 참고로 input 요소의 입력 필드에 한글을 입력하고 엔터 키를 누르면 keyup 이벤트 핸들러가 두 번 호출되는 현상이 발생하기 때문에 keyup 이벤트 대신 keydown 이벤트를 캐치한다.

![이벤트 전파](/Users/seanpeak/Projects/seanpeak-dev.github.io/seanpeak-dev/contents/imgs/이벤트-1.png)

예로 ul 요소에 이벤트 핸들러를 바인딩하고 ul 요소 하위인 li 요소를 클릭하여 이벤트를 발생시켰을 경우 이때 이벤트 타깃(event.target)은 li 요소이고 커런트 타깃(event.currentTarget)은 ul 요소이다. 이때 생성된 클릭 이벤트 객체는 window에서 시작해서 이벤트 타깃 방향으로 전파된다.(캡처링 단계) 이후 이벤트 객체는 이벤트를 발생시킨 이벤트 타깃에 도달한다.(타깃 단계) 이후 이벤트 객체는 이벤트 타깃에서 시작해서 window 방향으로 전파된다.(버블링 단계)

이벤트 핸들러 어트리뷰트/프로퍼티 방식으로 등록한 이벤트 핸들러는 타깃 단계와 버블링 단계의 이벤트만 캐치할 수 있다. 하지만 addEventListener 메서드 방식으로 등록한 이벤트 핸들러는 타깃 단계와 버블링 단계뿐만 아니라 캡처링 단계의 이벤트도 선별적으로 캐치할 수 있다.(addEventListener 메서드 3번째 인수로 true를 전달하면 된다.)  

대부분의 이벤트는 캡처링과 버블링을 통해 전파된다. 하지만 일부 이벤트는 버블링을 통해 전파되지 않는다. 이 이벤트들은 버블링을 통해 이벤트를 전파하는지 여부를 나타내는 이벤트 객체의 공통 프로퍼티 event.bubbles의 값이 모두 false다.
만약 이 이벤트를 상위 요소에서 캐치해야 할 경우는 많지 않지만 반드시 그래야 한다면 대체할 수 있는 이벤트가 존재한다. 예를 들어 mouseenter/mouseleave는 mouseover/mouseout으로 대체할 수 있다.  

## 이벤트 위임
여러 개의 하위 DOM 요소에 각각 이벤트 핸들러를 등록하는 대신 하나의 상위 DOM 요소에 이벤트 핸들러를 등록하는 방법을 말한다.  

주의할 점은 상위 요소에 이벤트 핸들러를 등록하기 때문에 이벤트 타깃, 즉 이벤트를 실제로 발생시킨 DOM 요소가 개발자가 기대한 DOM 요소가 아닐 수도 있다는 것이다.
따라서 이벤트에 반응이 필요한 DOM 요소에 한정하여 이벤트 핸들러가 실행되도록 이벤트 타깃을 검사할 필요가 있다.  

`Element.prototype.matches` 메서드는 인수로 전달된 선택자에 의해 특정 노드를 탐색 가능한지 확인한다.  

### DOM 요소의 기본 동작 중단
DOM 요소가 저마다 가지고 있는 기본 동작을 중단시키고 싶으면 이벤트 객체의 `preventDefault` 메서드를 이용한다.

### 이벤트 전파 방지
`stopPropagation` 메서드는 하위 DOM 요소의 이벤트를 개별적으로 처리하기 위해 이벤트의 전파를 중단시킨다.

### 이벤트 핸들러에 인수 전달
이벤트 핸들러 어트리뷰트 방식은 함수 호출문을 사용할 수 있기 때문에 인수를 전달할 수 있지만 
이벤트 핸들러 프로퍼티 방식과 addEventListener 메서드 방식의 경우 이벤트 핸들러를 브라우저가 호출하기 때문에 함수 호출문이 아닌 함수 자체를 등록해야 한다. 
따라서 인수를 전달할 수 없다.
하지만 이벤트 핸들러를 반환하는 함수를 호출하면서 인수를 전달하는 방법 등으로 인수를 전달하면 된다.

## 이벤트 핸들러 내부의 this
### 이벤트 핸들러 어트리뷰트 방식
이벤트 핸들러 어트리뷰트의 값으로 지정한 문자열은 사실 암묵적으로 생성되는 이벤트 핸들러의 문이기 때문에 일반 함수로 호출되며 일반 함수로 호출되는 함수 내부의 this는 전역 객체를 가리킨다.  

단, 이벤트 핸들러를 호출할 때 인수로 전달한 this는 이벤트를 바인딩한 DOM 요소를 가리킨다.

### 이벤트 핸들러 프로퍼티 방식과 addEventListener 메서드 방식
이벤트 핸들러 내부의 this는 이벤트를 바인딩한 DOM 요소를 가리킨다. 즉, 이벤트 핸들러 내부의 this는 이벤트 객체의 currentTarget 프로퍼티왁 같다.  

화살표 함수로 정의한 이벤트 핸들러 내부의 this는 상위 스코프의 this를 가리킨다. 화살표 함수는 자체의 this 바인딩을 갖지 않는다.  

클래스에서 이벤트 핸들러를 바인딩하는 경우 클래스 메서드 내부의 this는 클래스가 생성할 인스턴스를 가리키지 않기 때문에 이벤트 핸들러로 바인딩할 때 bind 메서드를 사용해 this를 전달하여 메서드 내부의 this가 클래스가 생성할 인스턴스를 가리키도록 해야한다.  

또는 클래스 메서드에 화살표 함수를 할당한 뒤 이를 이벤트 핸들러로 등록하여 이벤트 핸들러 내부의 this가 인스턴스를 가리키도록 할 수도 있다. 다만 이때 이벤트 핸들러는 프로토타입 메서드가 아닌 인스턴스 메서드가 된다.

### 커스텀 이벤트
이벤트 생성자 함수는 첫 번째 인수로 이벤트 타입을 나타내는 문자열을 전달받는다. 이 때 전달받는 문자열은 기존 이벤트 타입이 아닌 임의의 문자열을 사용하여 새로운 이벤트 타입을 지정할 수도 있다.  

생성된 커스텀 이벤트 객체는 버블링되지 않으며 preventDefault 메서드로 취소할 수도 없다. 즉, 커스텀 이벤트 객체는 bubbles와 cancelable 프로퍼티의 값이 false로 기본 설정된다.

이벤트 생성자 함수 두 번째 인수로 이벤트 타입에 따라 가지는 이벤트 고유의 프로퍼티 값을 지정해줄 수 있다.  

`dispatchEvent` 메서드에 이벤트 객체를 인수로 전달하면서 호출하면 인수로 전달한 이벤트 타입의 이벤트가 발생한다. 이때 생성자 함수에 두 번쨰 인수로 이벤트와 함께 전달하고 싶은 정보를 담은 detail 프로퍼티를 포함하는 객체를 전달할 수 있다.  

임의의 이벤트 타입을 지정하여 커스텀 이벤트 객체를 생성한 경우 반드시 addEventListener 메서드 방식으로 이벤트 핸들러를 등록해야 한다.  





