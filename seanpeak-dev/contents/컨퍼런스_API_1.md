---
date: '2021-10-21'
title: '프론트엔드를 위한 API 프로토콜, REST만이 답은 아니다.(with. gRPC, GraphQL)'
categories: ['컨퍼런스', 'API']
summary: '하나의 답은 없고, 상황에 맞는 선택을 해야 한다.'
---

## API
- 추상과 구체를 분리하여 나에게 당장 중요한 것에 더 집중할 수 있도록 해준다.

## REST API
- 리소스 중심으로 API가 구성된다.
- HTTP 메서드를 통해서 각 리소스에 액션을 정의한다.
- 주로 JSON 형식을 사용한다.

### REST API의 장점
- 사용이 쉽고, 자유도가 높아 원하는대로 사용이 가능하다.(이 부분은 단점이 될 수도 있다.)
- response 포맷이 JSON인 경우 파싱할 필요가 없다.

### REST API의 문제점
- 서버 API가 변경되면 프론트가 고장난다.
- API 버저닝도 가능은하지만 손이 많이가고, 코드와 문서가 멀어질수록 문서의 신뢰도는 떨어지고 죽은 문서가 될 가능성이 높다.

## IDL(인터페이스 정의 언어)
- 어떤 언어에 종속되지 않은 상태로 API를 정의할 수 있다.
- **REST API를 어떤 IDL를 이용하여 표현할 수 있을까?** → Open API(a.k.a Swagger API)

## Open API
- API 우선 접근을 할 수 있다.(API에 대한 규격을 먼저 정의하자. 그 다음 서버와 클라이언트가 구현을 하자.)
- 일반 문서와의 차이점은 Machine Readable Interface → 클라이언트 빌드, 서버 스텁(Stub) 빌드
- API 자체를 변경하지 않는 이상 구현부에서 API 스펙을 변경하는 것을 불가능하다.

### JS Client
- 실제 라이브러리를 빌드할 필요없이 API 정의 파일을 넣어주기만 하면 바로 사용이 가능하다. 
- API 정의 파일은 어떻게 관리하지? Makefile을 활용하여 특정 버전의 API 정의를 가져올 수 있도록 한다.

### Open API 장점
- 서버 디펜던시(서버와 클라이언트 사이의 개발 종속성) 대폭 감소

### Open API 단점
- 아쉬운 가독성
- 버전 규칙 관리 필요

## gRPC 통신
- 네트워크 호출이라고 생각하기보다 Function Call의 개념으로 접근한다.
- JSON 형태로 데이터를 주고 받는 것이 아니라 gRPC 형태로 데이터를 인코딩, 디코딩하며 주고 받는다.
- Protocol Buffers라는 IDL을 사용하며, 기본적으로는 하위 호환을 지원하는 형태로 API를 변경한다.
  - 하위 버전 클라이언트가 상위 버전 서버로 request를 보내도 문제가 발생하지 않도록 한다.
- HTTP/2를 사용하여 동작한다. 하지만 우리는 웹 브라우저가 HTTP/2를 사용하도록 강제할 수 없다.
  1. gRPC-Web Proxy를 통해 사이드카 프록시에서 웹 브라우저의 요청을 gRPC 요청으로 변경해주는 식으로 해결한다.
  2. Protocol Buffers IDL을 Open API IDL로 빌드하고, 빌드된 Open API 파일을 직접 로드해서 request를 보낼 수도 있다.

### gRPC 통신의 장점
- 속도가 빠르다.
- API 우선 접근 적용이 가능하다.
- 클라이언트/서버 스트리밍을 지원한다.

### gRPC 적용의 문제점
- 서버 환경 구성 및 운영 코스트 - 사이드카 프록시 필요
- MSA에서는 다수의 마이크로 서비스들이 존재
  - 인증을 모든 서비스마다 따로 해야하는지? 
  - 하나의 요청에서 여러 서비스를 호출해야 할 때는 어떻게 해야하지?
  - BFF(Backend For Frontend) 패턴 적용!

### BFF(Backend For Frontend)
- 모놀리틱 서비스에서는 사실상 인증 로직이 들어가 있는 REST API 프록시 서버로서의 역할을 수행했다.
- 각각의 애플리케이션(웹, 모바일)을 대상으로 각각의 서비스들을 만들어둔다.

## GraphQL
- API를 위한 쿼리 언어
- 서버 쪽에서 스키마를 정의하고, 클라이언트에서 원하는 데이터만 가져올 수 있도록 쿼리를 작성해서 데이터를 불러온다.
- 연결된 리소스들을 하나의 요청으로 함께 받을 수 있다.
- 버저닝 필요없이 서버쪽은 스키마나 기능들을 계속해서 구현해 나가고 클라이언트가 필요한 시점에 클라이언트 쪽을 업데이트 함으로써 추가적인 정보를 가져올 수 있다.

### GraphQL 적용의 문제점
- gRPC 통신의 경우 Protobuf를 사용하여 이미 자신들이 제공하는 API를 정의해 놓았는데 BFF에서 해당 API를 다시 한 번 정의하는 것 같은 느낌이 든다.(중복된 IDL)
- BFF에서 GraphQL Server Schema로 정의한 것을 GraphQL Client Query로 또 한 번 정의하는 것 같은 느낌이 든다.(중복된 IDL)
- Protobuf로부터 GraphQL Schema를 좀 더 쉽게 빌드할 수 있는 도구가 아직 활발하지는 않다.
- 하나의 API에서 한 번에 여러 서비스를 호출하는 일이 생각보다 많지는 않다.
- 대부분 REST API 철학으로 리소스를 중심으로 request를 보내는 것으로 문제가 해결될 수 있다.

## 소리치는 아키텍처
- 애플리케이션의 아키텍처가 리액트 아키텍처를 소리치고 있는지 아니면 비즈니스 아키텍처를 소리치고 있는지
- 비즈니스 로직을 핵심으로 구성하도록 제안, 인프라스트럭처 레이어나 데이터 레이어 지식을 최대한 떼내고 도메인 지식, 비즈니스 지식에 대해서만 신경을 쓰도록 만든다.
  - Repository Pattern(의존성 주입을 통한)
- Repository Pattern과 Dependency Injection을 통해 API Client와 상관 없이 비즈니스 로직 테스트가 가능하다.
- 그럼에도 Contract Test가 반드시 필요하다.(비즈니스 로직이 문제 없더라고 API가 제대로 동작 안하면 꽝이다.)
- IDL을 통해 상대적으로 쉽게 Mock Service 구성이 가능하다.