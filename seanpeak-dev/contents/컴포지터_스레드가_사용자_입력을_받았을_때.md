date: '2021-11-02'
title: '컴포지터 스레드가 사용자 입력을 받았을 때'
categories: ['브라우저']
summary: '메인 스레드로 이벤트를 전송하는 것을 최소화하기'
---
## 메인 스레드로 이벤트를 전송하는 것을 최소화하기
- 브라우저의 관점에서 입력이란 모든 사용자의 제스처를 의미한다.
- 화면 터치와 같은 사용자 제스처가 발생했을 때 가장 먼저 제스처를 수신하는 것은 브라우저 프로세스이다. 브라우저 프로세스는 제스처가 어디에서 발생했는지만 알고 있다. 탭 내부의 콘텐츠는 렌더러 프로세스가 처리해야 한다.
- 브라우저 프로세스는 이벤트 유형(예: touchstart )과 이벤트가 발생한 좌표를 렌더러 프로세스로 보낸다. 렌더러 프로세스는 이벤트 대상을 찾고 해당 대상과 연결된 이벤트 리스너를 실행해 이벤트를 적절하게 처리한다.
- 웹 페이지에 이벤트 리스너가 연결되어 있지 않으면 컴포지터 스레드는 메인 스레드와 상관없이 새로운 합성 프레임을 만들 수 있다. 하지만 이벤트 리스너가 웹 페이지에 연결되어 있다면 어떻게 될까?
- JavaScript 실행은 메인 스레드의 작업이므로 웹 페이지가 합성될 때 컴포지터 스레드는 이벤트 핸들러가 연결된 영역을 '고속 스크롤 불가 영역(non-fast scrollable region)'이라고 표시한다.
- 입력 이벤트가 고속 스크롤 불가 영역 밖에서 발생했다면 컴포지터 스레드는 메인 스레드를 기다리지 않고 새 프레임을 합성한다.
- 모든 요소에 대해 이벤트 핸들러를 하나만 작성하면 되므로 이런 이벤트 위임 패턴이 무척이나 편해 보이는 것이 당연하다. 그러나 브라우저의 관점에서 이 코드를 보면 이제 웹 페이지의 모든 영역이 고속 스크롤 불가 영역으로 표시된다.
- 즉, 애플리케이션이 신경 쓰지 않는 부분에 입력이 들어와도 컴포지터 스레드는 입력 이벤트가 들어올 때마다 메인 스레드와 통신해야 하고 메인 스레드가 일을 끝내기를 기다려야 한다. 그래서 컴포지터가 스크롤을 부드럽게 할 수 없게 된다.
- 이런 문제를 방지하기 위해 이벤트 리스너에서 passive: true 옵션을 전달할 수 있다. 이 옵션은, 여전히 메인 스레드에서 이벤트를 받지만 컴포지터가 메인 스레드의 처리를 기다리지 않고 새 프레임을 만들어도 된다는 힌트를 브라우저에 주는 옵션이다.
- [Lighthouse](https://developers.google.com/web/tools/lighthouse/)
- [성능 측정 방법](https://developer.chrome.com/docs/devtools/speed/get-started/#goal_of_tutorial)
