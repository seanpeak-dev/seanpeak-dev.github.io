{
    "componentChunkName": "component---src-templates-post-template-tsx",
    "path": "/컴포지터_스레드가_사용자_입력을_받았을_때/",
    "result": {"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<h2>메인 스레드로 이벤트를 전송하는 것을 최소화하기</h2>\n<ul>\n<li>브라우저의 관점에서 입력이란 모든 사용자의 제스처를 의미한다.</li>\n<li>화면 터치와 같은 사용자 제스처가 발생했을 때 가장 먼저 제스처를 수신하는 것은 브라우저 프로세스이다. 브라우저 프로세스는 제스처가 어디에서 발생했는지만 알고 있다. 탭 내부의 콘텐츠는 렌더러 프로세스가 처리해야 한다.</li>\n<li>브라우저 프로세스는 이벤트 유형(예: touchstart )과 이벤트가 발생한 좌표를 렌더러 프로세스로 보낸다. 렌더러 프로세스는 이벤트 대상을 찾고 해당 대상과 연결된 이벤트 리스너를 실행해 이벤트를 적절하게 처리한다.</li>\n<li>웹 페이지에 이벤트 리스너가 연결되어 있지 않으면 컴포지터 스레드는 메인 스레드와 상관없이 새로운 합성 프레임을 만들 수 있다. 하지만 이벤트 리스너가 웹 페이지에 연결되어 있다면 어떻게 될까?</li>\n<li>JavaScript 실행은 메인 스레드의 작업이므로 웹 페이지가 합성될 때 컴포지터 스레드는 이벤트 핸들러가 연결된 영역을 ‘고속 스크롤 불가 영역(non-fast scrollable region)‘이라고 표시한다.</li>\n<li>입력 이벤트가 고속 스크롤 불가 영역 밖에서 발생했다면 컴포지터 스레드는 메인 스레드를 기다리지 않고 새 프레임을 합성한다.</li>\n<li>모든 요소에 대해 이벤트 핸들러를 하나만 작성하면 되므로 이런 이벤트 위임 패턴이 무척이나 편해 보이는 것이 당연하다. 그러나 브라우저의 관점에서 이 코드를 보면 이제 웹 페이지의 모든 영역이 고속 스크롤 불가 영역으로 표시된다.</li>\n<li>즉, 애플리케이션이 신경 쓰지 않는 부분에 입력이 들어와도 컴포지터 스레드는 입력 이벤트가 들어올 때마다 메인 스레드와 통신해야 하고 메인 스레드가 일을 끝내기를 기다려야 한다. 그래서 컴포지터가 스크롤을 부드럽게 할 수 없게 된다.</li>\n<li>이런 문제를 방지하기 위해 이벤트 리스너에서 passive: true 옵션을 전달할 수 있다. 이 옵션은, 여전히 메인 스레드에서 이벤트를 받지만 컴포지터가 메인 스레드의 처리를 기다리지 않고 새 프레임을 만들어도 된다는 힌트를 브라우저에 주는 옵션이다.</li>\n<li><a href=\"https://developers.google.com/web/tools/lighthouse/\" target=\"_blank\" rel=\"nofollow\">Lighthouse</a></li>\n<li><a href=\"https://developer.chrome.com/docs/devtools/speed/get-started/#goal_of_tutorial\" target=\"_blank\" rel=\"nofollow\">성능 측정 방법</a></li>\n</ul>","frontmatter":{"title":"컴포지터 스레드가 사용자 입력을 받았을 때","summary":"메인 스레드로 이벤트를 전송하는 것을 최소화하기","date":"2021.11.02.","categories":["브라우저"]}}}]}},"pageContext":{"slug":"/컴포지터_스레드가_사용자_입력을_받았을_때/"}},
    "staticQueryHashes": []}